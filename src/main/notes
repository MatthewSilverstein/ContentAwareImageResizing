Notes
Start with full picture, and only shrinking.
Find lowest path, remove it, move everything else over, set everything at the end to black
How to remove path? Create a stack FILO, and as paths are removed, they're added to the stack.
	Could even create a double sided stack FILO for when you add paths back to picture to solve
What is a path? It needs to have a list of indices attached to a byte[] which represents the colour.
This way you can keep removing paths and update the array and not have to deal with offX,offY

Ok structure:
	ListRGB: A partially filled array of the current byte[] represented in the picture
		All empty elements are at the end of rows and columns
	Path: a list of indices attached to byte[]s for the colour.
	DES: double ended stack of paths which keeps track of paths that are still in the picture
		Maybe not a double ended stack, but rather two stacks, one for when |new image|<=|original image| and one for when |new image|>|original image|
		DESS: the component that checks when |new image|<=|original image|
		DESG: the component that checks when |new image|>|original image|
	SIS: shrink image stack, stores paths that get removed when |new image|<=|original image|
	GIS: grow image stack, stores paths that get removed when |new image|>|original image|
Shrink picture
	--> Check to see if DESS is empty
		-->If DESS is not empty
			-->Path p=DESS.pop()
			-->removePath(p)
		-->If DESS is empty
			-->Path p=calculateMinPath()
			-->removePath(p)
		-->SIS.add(p)
		-->redrawPicture()

		
//Going to need two functions, remove horizontal paths, and remove vertical paths, this one is for horizontal
removePath(p){
	for (int i=0;i<p.size();i++){
		int[] index=p.get(i)
		removeIndex(index);
	}
}

//Slides every pixel to the right and on the same row as index one to the left.
removeIndex(int[] index){
	for (int i=index[0],j=index[1];i<width-1;i++){
		ListRBG[i][j]=listRBG[i+1][j];
	}
	listRBG[width-1][index[1]]=0x000000;
}

//Could make more efficient by only updating portions of image that need to be updated, but for now it'll update everything
redrawPicture(){
	for (int i=0;i<listRBG.length;i++){	//Later on change listRBG.length to width (when screen is actually growing and shrinking
		for (int j=0;j<listRBG[0].length;j++){
			img.setRBG(listRBG[i][j]);
		}
	}
	repaint();
}

ok structure
hGradients[][]
vGradients[][]
changeSize(){
	changePicture(dh,dv)
}

//Gradients are already calculated
chagePicture(dh,dv){
	changeH(dh)
	changeV(dv)
	updatePicture()
}

changeH(dh){
	calculateMinPathH()
	path=extractPathH()
	removePathH(path)
}

removePathH(path){
	for each index in path:
		remove specific index
		recalculate horizontal gradients for the adjacent indices
}